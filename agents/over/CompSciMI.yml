type: mixin
system_bottom: |-
  +

  # Algorithms & Data Structures

  ## Problem Classes
  P, NP, NP-complete, NP-hard, PSPACE, undecidable

  ## Data Structures

  ### Hash-Based
  - **Cuckoo Hashing:** O(1) worst-case lookup
  - **Bloom Filters:** Probabilistic membership, false positives possible

  ### Trees
  - **Splay Trees:** Self-adjusting, amortized O(log n)
  - **AA-Trees:** Simplified red-black
  - **Suffix Trees/Arrays:** O(m) string ops, construction variants
  - **Radix Trees:** Compressed tries

  ### Heaps
  - **Binomial/Fibonacci:** O(1) amortized decrease-key
  - **Pairing Heap, d-ary Heaps**

  ### Specialized
  - **Segment Trees, Fenwick (BIT):** Range queries/updates
  - **K-d Trees, Range Trees, Interval Trees:** Spatial/geometric
  - **Quad/Octrees:** Spatial decomposition

  ### Union-Find
  - **Path Compression + Union by Rank:** O(α(n))

  ### Advanced
  - **Persistent:** Path copying, fat nodes
  - **Succinct/Compressed:** Wavelet trees, rank/select
  - **Cache-Oblivious Structures**

  ## Sorting & Selection

  **Comparison:** Introsort (quicksort→heapsort), Timsort (merge+insertion, adaptive)
  **Non-Comparison:** Counting O(n+k), Radix O(d(n+k)), Bucket O(n) avg
  **Selection:** Quickselect O(n) avg, Median-of-Medians O(n) worst

  ## Searching

  **Binary Search:** O(log n) sorted. Rightmost: `while l<r: m=(l+r+1)//2; if p(m): l=m; else: r=m-1`. Leftmost: `while l<r: m=(l+r)//2; if p(m): r=m; else: l=m+1`
  **Binary Search:** O(log n) sorted. Leftmost True: `while l<r: m=(l+r)//2; if not p(m): l=m+1; else: r=m`. Rightmost True: `while l<r: m=(l+r+1)//2; if p(m): l=m; else: r=m-1`
  **Ternary Search:** Unimodal functions O(log n), eliminate 1/3 per iteration
  **Interpolation:** `pos=l+((x-a[l])/(a[r]-a[l]))*(r-l)`. O(log log n) uniform, O(n) worst
  **Jump/Fibonacci:** O(√n) block jumps; Fibonacci uses single comparison/iteration
  **Bidirectional:** Meet-in-middle O(b^(d/2)). A* with f=g+h, admissible h. IDA* depth-first iterative
  **BS on Answer:** Binary search solution value when monotonic + validation function

  ## Graph Algorithms

  ### Shortest Paths
  - **Johnson's:** O(V² log V + VE), all-pairs with reweighting
  - **A*:** Heuristic-guided Dijkstra

  ### MST
  - **Borůvka:** O(E log V), parallel-friendly

  ### Network Flow
  - **Dinic:** O(V²E), **Push-Relabel:** O(V³)
  - **Min-Cut/Max-Flow duality**

  ### Matching
  - **Hopcroft-Karp:** O(E√V) bipartite
  - **Blossom (Edmonds):** O(V²E) general

  ### Connectivity
  - **SCC:** Kosaraju, Tarjan O(V+E)
  - **Biconnected:** Articulation points, bridges
  - **2-SAT:** O(V+E) via SCC

  ### Cycles & Ordering
  - **Euler Path:** O(E) Hierholzer's
  - **Hamiltonian:** NP-complete, DP O(n²·2ⁿ)

  ### Advanced
  - **Planarity Testing:** O(V) Hopcroft-Tarjan
  - **Maximum Clique/Independent Set:** NP-complete

  ## String Algorithms

  ### Pattern Matching
  - **KMP:** O(n+m) failure function
  - **Boyer-Moore:** O(n+m) skip heuristics
  - **Rabin-Karp:** Rolling hash
  - **Aho-Corasick:** O(n+m+z) multi-pattern, trie + failure links

  ### Structures
  - **Burrows-Wheeler Transform, FM-index**

  ### Distance
  - **Levenshtein:** O(nm) DP
  - **Needleman-Wunsch, Smith-Waterman:** Sequence alignment

  ### Misc
  - **Manacher's:** O(n) longest palindrome
  - **Z-Algorithm:** O(n) prefix matching

  ## Dynamic Programming Patterns

  ### Tree DP
  - **Tree Diameter, Independent Set on Trees**

  ### Bitmask DP
  - **TSP (Held-Karp):** O(n²·2ⁿ)

  ### Optimization
  - **Convex Hull Trick, Divide & Conquer DP:** O(kn log n)
  - **Space optimization:** Rolling arrays

  ## Greedy Algorithms

  **Approximation:** Set Cover O(log n), Vertex Cover 2-approx, TSP 2-approx, Christofides 3/2

  ## Divide & Conquer

  **Multiplication:** Karatsuba O(n^1.585), Strassen O(n^2.807), FFT O(n log n)
  **Master Theorem:** T(n) = aT(n/b) + f(n)

  ## Computational Geometry

  ### Convex Hull
  - **Jarvis March:** O(nh), **Andrew's, Chan's:** O(n log h)

  ### Sweepline
  - **Bentley-Ottmann:** O((n+k) log n) segment intersection
  - **Fortune's:** O(n log n) Voronoi

  ### Range Queries
  - **Range Trees:** O(log^d n + k)
  - **K-d Trees:** O(n^(1-1/d) + k)

  ## Bit Manipulation

  **XOR Tricks:** Swap, find unique element, subset enumeration
  **Gray Code**

  ## Randomized Algorithms

  **Las Vegas vs. Monte Carlo:** Always correct vs. probabilistic
  **Techniques:** Reservoir Sampling, Rabin-Miller primality
  **Structures:** Universal Hashing, Treaps

  ## Approximation & Heuristics

  **Local Search:** Simulated Annealing, Genetic Algorithms
  **Bin Packing:** First/Best-Fit approximations

  ## Parallel & Concurrent

  **Patterns:** Scan/Prefix Sum O(log n) parallel, Bitonic/Sample sort
  **Synchronization:** Lock-Free (CAS, ABA problem), Work Stealing

  ## Advanced Topics

  **Amortized Analysis:** Aggregate, Accounting, Potential methods
  **Online Algorithms:** Competitive analysis, Ski Rental
  **Streaming:** Count-Min Sketch, HyperLogLog, Misra-Gries
  **External Memory:** External sorting algorithms
  **Quantum:** Grover's O(√n) search, Shor's polynomial factoring

  ## Practical Considerations

  **Implementation:** Cache locality, branch prediction, SIMD
  **Constants matter:** Profile asymptotic vs. real performance
  **Testing:** Fuzzing, property-based testing

  *Recognize patterns, choose appropriate structures/algorithms, adapt theory to constraints.*
