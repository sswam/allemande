#!/bin/bash

# llm-git-commit: git commit with a message generated by an LLM.

# Ensure Bash version 4 or higher for associative arrays
if ((BASH_VERSINFO[0] < 4)); then
    echo "Error: This script requires Bash 4.0 or higher." >&2
    exit 1
fi

. confirm

diff_context=10   # lines of context for diffs

# Associative arrays mapping model codes to names and options
declare -A model_names=(
    ["4"]="GPT-4"
    ["4m"]="GPT-4o-mini"
    ["op"]="OpenAI o1"
    ["om"]="OpenAI o1-mini"
    ["c"]="Claude"
    ["i"]="Claude Instant"
)

declare -A option_model_codes=(
    ["3"]="4m"
    ["4"]="4"
    ["c"]="c"
    ["i"]="i"
    ["M"]="om"
    ["o"]="op"
)

usage() {
    echo "Usage: llm-git-commit [-4|-n|-3|-c|-i|-o|-M] [-m message] [-e] [-h]"
    echo "  -n: start at menu, do not generate"
    for opt in "${!option_model_codes[@]}"; do
        model_code="${option_model_codes[$opt]}"
        model_name="${model_names[$model_code]}"
        echo "  -$opt: generate with $model_name"
    done
    echo "  -m: use the given message instead of generating one"
    echo "  -e: normal git commit using the editor"
    echo "  -h: show this help message"
    echo "  -x: clean up commit-message.*.txt files"
}

model="$ALLEMANDE_LLM_DEFAULT"

if type move-rubbish >/dev/null 2>&1; then
    MR=move-rubbish
else
    MR="rm -f"
fi

timestamp=$(date +%Y%m%d%H%M%S)
commit_message="commit-message.$timestamp.txt"
review="review.$timestamp.txt"

cleanup() {
    # Remove empty commit messages that are not open
    find . -type f -name 'commit-message.*.txt' -size 0 2>/dev/null | while read -r file; do
        if ! lsof "$file" >/dev/null 2>&1; then
            rm -v "$file"
        fi
    done
}

cleanup-and-exit() {
    $MR "$commit_message" "$review" 2>/dev/null
    exit "$1"
}

trap 'cleanup-and-exit 0' EXIT
trap 'cleanup-and-exit 1' INT

while getopts "4n3cioMm:exh" opt; do
    case "$opt" in
    n)
        model=""
        ;;
    m)
        exec git commit -m "$OPTARG"
        ;;
    e)
        exec git commit
        ;;
    x)
        cleanup
        exit
        ;;
    h)
        usage
        exit 0
        ;;
    *)
        if [[ -n "${option_model_codes["$opt"]}" ]]; then
            model="${option_model_codes["$opt"]}"
        else
            usage
            exit 1
        fi
        ;;
    esac
done
shift $((OPTIND-1))

# Add entries under directories
files=()
for ent; do
    if [ -d "$ent" ] && [ ! -L "$ent" ]; then
        IFS_old=$IFS
        IFS=$'\n'; files+=( $(find "$ent" ! -type d) )
        IFS=$IFS_old
    else
        files+=( "$ent" )
    fi
done

# Absolute paths
for i in "${!files[@]}"; do
    files[$i]=$(realpath "${files[$i]}")
done

# Change directory to the top level of the git repository
if [ -n "${files[0]}" ]; then
    cd "$(dirname "${files[0]}")"
fi
git_root=$(git rev-parse --show-toplevel)
cd "$git_root"

# Relative paths to git_root
for i in "${!files[@]}"; do
    files[$i]=$(realpath --relative-to="$git_root" "${files[$i]}")
done

# Unstage if already staged
if [ "${#files[@]}" -gt 0 ] && ! git diff --staged --quiet "${files[@]}"; then
    v git restore --staged "${files[@]}"
fi

model-name() {
    echo "${model_names["$1"]}"
}

run-git-diff() {
    local difftext
    if [ "${#files[@]}" -eq 0 ]; then
        git diff -U$diff_context --staged
    else
        difftext=$(git diff -U$diff_context -- "${files[@]}")
        if [ -n "$difftext" ]; then
            printf "%s\n" "$difftext"
        else
            for file in "${files[@]}"; do
                if [ -e "$file" ] && [ -n "$(git ls-files --exclude-standard --others --directory --no-empty-directory --error-unmatch "$file" 2>/dev/null)" ]; then
                    cat-sections.py -k "$file"
                fi
            done
        fi
    fi
}

generate-commit-message() {
    model="$1"
    echo "Generating commit message using $(model-name "$model") ..."
    if [ -e "$commit_message" ]; then
        echo >&2 "Commit message already exists: $commit_message, moving it to rubbish."
        $MR "$commit_message"
    fi

    run-git-diff | llm process -m "$model" 'Please describe this entire patch, for a git commit message, following the Conventional Commits spec.
Do not invent anything that is not in the patch!
Only describe the actual changes, lines starting with +, do not describe the surrounding patch context.
The required format is as follows. Return only the commit message like this without any prelude or concluding statement!

For a feature patch, focus on describing high-level features, without implementation details. For fixes and some other types, it makes sense to mention some details of the bug and fix.

Seriously, for a new feature *DO NOT* describe implementation details, variables, functions, etc. (Except for a library it would be appropriate to describe a new function; but not normally to get into how it works.)

feat|fix|docs|style|refactor|test|chore|perf(short-module-name): a short summary line, preferably around 50 chars, not more than 70 chars

- concise info about first change, if needed. If the line wraps
  the second line must be indented like this.
- concise info about second change, if any.
- and so on ... but sometimes we do not need details, in which case just the header line is okay. *LESS IS MORE!*

There can be only one feat or fix line per commit, then a blank line, then the list.
If a commit is simple, you can omit the list. Do not add a list item that just repeats the main line.
The (short-module-name) part is optional. Commit type can be feat|fix|chore etc.
Do not belabour the obvious; we do not need too much detail, e.g. moving folders do not list every file that was moved.
' | grep -v '^```' | perl -e '
    @lines = <STDIN>;
    if (@lines && $lines[0] =~ /:$/) {
        warn "removing header: $lines[0]\n";
        shift @lines;
        if (@lines && $lines[0] =~ /^$/) {
            shift @lines;
        }
    }
    print join("", @lines);
' | fmt -s -w 78 -g 78 | rstrip > "$commit_message"
}

check-for-bugs() {
    model="$1"
    echo "Checking for bugs using $(model-name "$model") ..."
    if [ -e "$review" ]; then
        echo >&2 "Code review already exists: $review, moving it to rubbish."
        $MR "$review"
    fi
    run-git-diff | proc -m="$model" 'Please carefully review this patch with a fine-tooth comb! Answer LGTM if bug-free, or list bugs still present in the patched code. Do NOT list bugs in the original code that are fixed by the patch. You may also list other issues or suggestions if they are important. Expected format:

1. bug or issue
2. another bug or issue

or just LGTM.
' | fmt -s -w 78 -g 78 | tee "$review"
}

if [ -n "$model" ]; then
    confirm check-for-bugs "$model"
    if [ ! -e "$review" ] || [ "$(cat "$review")" = "LGTM" ]; then
        generate-commit-message "$model"
    fi
fi

run-git-vimdiff() {
    if [ "${#files[@]}" -eq 0 ]; then
        git-vimdiff-staged
    else
        git-vimdiff "${files[@]}"
    fi
}

while true; do
    if [ -e "$commit_message" ]; then
        cat "$commit_message"
        echo
        prompt="Commit with this message?"
    else
        prompt="Action?"
    fi
    read -p "$prompt [y/n/q/e/3/4/c/i/o/M/d/v/b/?] " -n 1 -r choice
    echo
    case "$choice" in
        y)
            break
            ;;
        n|q)
            cleanup-and-exit 1
            ;;
        e)
            ${EDITOR:-vi} "$commit_message"
            ;;
        d)
            run-git-diff
            ;;
        v)
            run-git-vimdiff
            ;;
        b)
            check-for-bugs "c"
            ;;
        x)
            cleanup
            ;;
        \?|h)
            echo "Available actions:"
            echo "  y: commit with this message"
            echo "  n/q: abort"
            echo "  e: edit the message"
            for ch in "${!option_model_codes[@]}"; do
                model_code="${option_model_codes["$ch"]}"
                model_name="${model_names["$model_code"]}"
                echo "  $ch: generate with $model_name"
            done
            echo "  d: diff the staged changes"
            echo "  v: vimdiff the staged changes"
            echo "  b: check for bugs with Claude"
            echo "  ?: show this help message"
            echo "  x: clean up commit-message.*.txt files"
            echo
            ;;
        *)
            if [[ -n "${option_model_codes["$choice"]}" ]]; then
                generate-commit-message "${option_model_codes["$choice"]}"
            else
                echo "Invalid choice"
            fi
            ;;
    esac
done

if [ "${#files[@]}" -gt 0 ]; then
    git add -- "${files[@]}"
fi

git commit -F "$commit_message"
