#!/bin/bash

# llm-git-commit: git commit with a message generated by an LLM.

# Ensure Bash version 4 or higher for associative arrays
if ((BASH_VERSINFO[0] < 4)); then
    echo "Error: This script requires Bash 4.0 or higher." >&2
    exit 1
fi

. confirm

diff_context=10   # lines of context for diffs

# Associative arrays mapping model codes to names and options
declare -A model_names=(
    ["4"]="GPT-4"
    ["4m"]="GPT-4o-mini"
    ["op"]="OpenAI o1"
    ["om"]="OpenAI o1-mini"
    ["c"]="Claude"
    ["i"]="Claude Instant"
)

declare -A option_model_codes=(
    ["3"]="4m"
    ["4"]="4"
    ["c"]="c"
    ["i"]="i"
    ["M"]="om"
    ["o"]="op"
)

usage() {
    echo "Usage: llm-git-commit [-4|-n|-3|-c|-i|-o|-M] [-m message] [-e] [-h]"
    echo "  -n: start at menu, do not generate"
    for opt in "${!option_model_codes[@]}"; do
        model_code="${option_model_codes[$opt]}"
        model_name="${model_names[$model_code]}"
        echo "  -$opt: generate with $model_name"
    done
    echo "  -m: use the given message instead of generating one"
    echo "  -e: normal git commit using the editor"
    echo "  -h: show this help message"
    echo "  -x: clean up commit-message.*.txt files"
}

model="d"

if type move-rubbish >/dev/null 2>&1; then
    MR=move-rubbish
else
    MR="rm -f"
fi

timestamp=$(date +%Y%m%d%H%M%S)
commit_message="commit-message.$timestamp.txt"
review="review.$timestamp.txt"

cleanup() {
    # Remove empty commit messages that are not open
    find . -type f -name 'commit-message.*.txt' -size 0 2>/dev/null | while read -r file; do
        if ! lsof "$file" >/dev/null 2>&1; then
            rm -v "$file"
        fi
    done
}

cleanup-and-exit() {
    $MR "$commit_message" "$review" 2>/dev/null
    exit "$1"
}

git-commit() {
    git commit "$@" "${files[@]:-.}"
}

trap 'cleanup-and-exit 0' EXIT
trap 'cleanup-and-exit 1' INT

while getopts "4n3cioMm:exh" opt; do
    case "$opt" in
    n)
        model=""
        ;;
    m)
        git-commit -m "$OPTARG"
        exit 0
        ;;
    e)
        git-commit
        exit 0
        ;;
    x)
        cleanup
        exit
        ;;
    h)
        usage
        exit 0
        ;;
    *)
        if [[ -n "${option_model_codes["$opt"]}" ]]; then
            model="${option_model_codes["$opt"]}"
        else
            usage
            exit 1
        fi
        ;;
    esac
done
shift $((OPTIND-1))

git-staged() {
    git diff --cached --name-status | kut_perl.pl -o 1 | tr '\t' '\n'
}

# handle the list of files

files=( "$@" )

# Find the top level of the git repository
git_root=$(git rev-parse --show-toplevel)

if [ -z "$git_root" ]; then
    exit 1
fi

original_dir=$PWD

# if no files were given, use staged
if [ "${#files[@]}" -eq 0 ]; then
    cd "$git_root"
    readarray -t files < <(git-staged)
else
    git add -A -- "${files[@]}"
fi
if [ "${#files[@]}" -eq 0 ]; then
    cd "$original_dir"
    git add -A .
    cd "$git_root"
    readarray -t files < <(git-staged)
fi
if [ "${#files[@]}" -eq 0 ]; then
    echo >&2 "No files to commit."
    exit 1
fi

# Paths relative to git_root
for i in "${!files[@]}"; do
    files[$i]=$(realpath --no-symlinks --relative-to="$git_root" "${files[$i]}")
done

cd "$git_root"

# Inform the user of the files to be committed
echo "Files to commit:"
for file in "${files[@]}"; do
    echo "  $file"
done
echo

model-name() {
    local name="${model_names["$1"]}"
    if [ -z "$name" ]; then
        case "$1" in
            d) name="$ALLEMANDE_LLM_DEFAULT" ;;
            s) name="$ALLEMANDE_LLM_DEFAULT_SMALL" ;;
            *) name="[unknown model: $1]" ;;
        esac
    fi
    echo "$name"
}

run-git-diff() {
    local opts=("$@")
    local difftext
    if [ "${#files[@]}" -eq 0 ]; then
        git diff --staged -U$diff_context "${opts[@]}"
    else
        for file in "${files[@]}"; do
            difftext=$(git diff --staged -U$diff_context "${opts[@]}" -- "$file")
            if [ -n "$difftext" ]; then
                printf "%s\n" "$difftext"
            elif [ -e "$file" ] && [ -n "$(git ls-files --exclude-standard --others --directory --no-empty-directory --error-unmatch "$file" 2>/dev/null)" ]; then
                cat_named.py "$file"
            fi
        done
    fi
}

generate-commit-message() {
    model="$1"
    echo "Generating commit message using $(model-name "$model") ..."
    if [ -e "$commit_message" ]; then
        echo >&2 "Commit message already exists: $commit_message, moving it to rubbish."
        $MR "$commit_message"
    fi

    run-git-diff | llm process -m "$model" 'Please describe this entire patch, for a git commit message, following the Conventional Commits spec.
Do not invent anything that is not in the patch!
Only describe the actual changes, lines starting with +, do not describe the surrounding patch context.
The required format is as follows. Return only the commit message like this without any prelude or concluding statement!

For a feature patch, focus on describing high-level features, without implementation details. For fixes and some other types, it makes sense to mention some details of the bug and fix.

Seriously, for a new feature *DO NOT* describe implementation details, variables, functions, etc. (Except for a library it would be appropriate to describe a new function; but not normally to get into how it works.)

feat|fix|docs|style|refactor|test|chore|perf(short-module-name): a short summary line, preferably around 50 chars, not more than 70 chars

[IF ANY ONLY IF IT IS NECESSARY, continue with details as below]

- concise info about first change, if needed. If the line wraps
  the second line must be indented like this.
- concise info about second change, if any.
- and so on ... but LESS IS MORE!

The (short-module-name) part is useful, but optional. Commit type can be feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert etc.
Do not belabour the obvious; we do not need too much detail, e.g. moving folders do not list every file that was moved.
Be careful that you only comment on the [-+] changes in the diff, not the context lines.

Please write the message in a down-to-earth tone, avoiding extravagant-sounding words like "enhance".
' | grep -v '^```' | perl -e '
    @lines = <STDIN>;
    if (@lines && $lines[0] =~ /:$/) {
        warn "removing header: $lines[0]\n";
        shift @lines;
        if (@lines && $lines[0] =~ /^$/) {
            shift @lines;
        }
    }
    print join("", @lines);
' | fmt -s -w 78 -g 78 | rstrip > "$commit_message"
    echo
}

check-for-bugs() {
    model="$1"
    echo "Checking for bugs using $(model-name "$model") ..."
    if [ -e "$review" ]; then
        echo >&2 "Code review already exists: $review, moving it to rubbish."
        $MR "$review"
    fi
    run-git-diff | proc -m="$model" "Please carefully review this patch with a fine-tooth comb
Answer LGTM if bug-free, or list bugs still present in the patched code.
Do NOT list bugs in the original code that are fixed by the patch.
Also list other issues or suggestions if they are important.
Especially, check for sensitive information such as private keys or email addresses
that should not be committed to git. Deliberate author's email is okay.
Also note any grossly bad code or gross inefficiencies.

Expected format:

1. bug or issue
2. another bug or issue

or if nothing is wrong, please just wrte 'LGTM'.
" | fmt -s -w 78 -g 78 | tee "$review"
    echo
}

if [ -n "$model" ]; then
    # confirm check-for-bugs "$model"
    if [ ! -e "$review" ] || [ "$(cat "$review")" = "LGTM" ]; then
        generate-commit-message "$model"
    fi
fi

run-git-vimdiff() {
    if [ "${#files[@]}" -eq 0 ]; then
        git-vimdiff-staged
    else
        git-vimdiff "${files[@]}"
    fi
}

while true; do
    if [ -e "$commit_message" ]; then
        cat "$commit_message"
        echo
        prompt="Commit with this message?"
    else
        prompt="Action?"
    fi
    read -p "$prompt [y/n/q/e/3/4/c/i/o/M/d/v/b/?] " -n 1 -r choice
    echo
    case "$choice" in
        y)
            break
            ;;
        n|q)
            cleanup-and-exit 1
            ;;
        e)
            ${EDITOR:-vi} "$commit_message"
            ;;
        d)
            run-git-diff --color | less -F -X -e -i -M -R -W -z-4
            ;;
        v)
            run-git-vimdiff
            ;;
        b)
            check-for-bugs ""
            ;;
        x)
            cleanup
            ;;
        \?|h|"")
            echo "Available actions:"
            echo "  y: commit with this message"
            echo "  n/q: abort"
            echo "  e: edit the message"
            for ch in "${!option_model_codes[@]}"; do
                model_code="${option_model_codes["$ch"]}"
                model_name="${model_names["$model_code"]}"
                echo "  $ch: generate with $model_name"
            done
            echo "  d: diff the staged changes"
            echo "  v: vimdiff the staged changes"
            echo "  b: check for bugs"
            echo "  ?: show this help message"
            echo "  x: clean up commit-message.*.txt files"
            echo
            ;;
        *)
            if [[ -n "${option_model_codes["$choice"]}" ]]; then
                generate-commit-message "$choice"
            else
                echo >&2 "Invalid choice"
            fi
            ;;
    esac
    echo
done

# if [ "${#files[@]}" -gt 0 ]; then
#     git add -- "${files[@]}"
# fi

git-commit -F "$commit_message"
