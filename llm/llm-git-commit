#!/bin/bash
# llm-git-commit: git commit with a message generated by GPT-4, ChatGPT, Claude, Claude Instant, Claude 100k, Claude Instant 100k.

. confirm

model_code=""

usage() {
	echo "Usage: llm-git-commit [-4|-n|-3|-c|-i] [-m message] [-e] [-h]"
	echo "  -4: generate with GPT-4 (default)"
	echo "  -n: start at menu, do not generate"
	echo "  -3: generate with ChatGPT-3.5"
	echo "  -c: generate with Claude"
	echo "  -C: generate with Claude 100k"
	echo "  -i: generate with Claude Instant"
	echo "  -I: generate with Claude Instant 100k"
	echo "  -m: use the given message instead of generating one"
	echo "  -e: normal git commit using the editor"
	echo "  -h: show this help message"
	echo "  -x: clean up commit-message.*.txt files"
}

model="c"

if type move-rubbish >/dev/null 2>&1; then
	MR=move-rubbish
else
	MR=rm -f
fi

cleanup() {
	# remove empty commit messages, that are not open
	f -type f -name 'commit-message.*.txt' -size 0 -- |
	while read -r file; do
		if ! lsof "$file" >/dev/null 2>&1; then
			rm -v "$file"
		fi
	done
}

trap 'cleanup-and-exit 0' EXIT
trap 'cleanup-and-exit 1' INT

while getopts "4n3cCiIm:exh" opt; do
	case "$opt" in
	4 ) model="4";;
	n ) model="";;
	3 ) model="3+";;
	c ) model="c";;
	C ) model="c+";;
	i ) model="i";;
	I ) model="i+";;
	m ) exec git commit -m "$OPTARG" ;;
	e ) exec git commit ;;
	x ) cleanup ; exit ;;
	h ) usage; exit 0;;
	* ) usage; exit 1;;
	esac
done
shift $((OPTIND-1))

# add entries under directories
files=()
for ent; do
	if [ -d "$ent" -a \! -L "$ent" ]; then
		IFS_old=$IFS
		IFS=$'\n'; files+=( $( find "$ent" \! -type d ) )
		IFS=$IFS_old
	else
		files+=( "$ent" )
	fi
done

# absolute paths
for i in "${!files[@]}"; do
	files[$i]=$(realpath "${files[$i]}")
done

# chdir to top level of git repo
if [ -n "${files[0]}" ]; then
	cd "$(dirname "${files[0]}")"
fi
git_root=$(git rev-parse --show-toplevel)
cd "$git_root"

# relative to git_root
for i in "${!files[@]}"; do
	files[$i]=$(realpath --relative-to="$git_root" "${files[$i]}")
done

# check if already staged; in which case, unstage, it works better that way
for file in "${files[@]}"; do
	if ! git diff --staged --quiet "${files[@]}"; then
		v git restore --staged "${files[@]}"
	fi
done

timestamp=`date +%Y%m%d%H%M%S`
commit_message="commit-message.$timestamp.txt"
review="review.$timestamp.txt"

model-name() {
	model="$1"
	case "$model" in
	3+ ) echo "ChatGPT-3.5";;
	4 ) echo "GPT-4";;
	c ) echo "Claude";;
	c+ ) echo "Claude 100k";;
	i ) echo "Claude Instant";;
	i+ ) echo "Claude Instant 100k";;
	esac
}

run-git-diff() {
	local difftext
	if [ "${#files[@]}" -eq 0 ]; then
		git diff --staged
	else
		difftext=`git diff -- "${files[@]}"`
		if [ -n "$difftext" ]; then
			printf "%s\n" "$difftext"
		elif [ -z "$difftext" ]; then
			for file in "${files[@]}"; do
				if [ -e "$file" ] && [ -n "$(git ls-files --exclude-standard --others --directory --no-empty-directory --error-unmatch "$file" 2>/dev/null)" ]; then
					cat-sections.py -k "$file"
				fi
			done
		fi
	fi
}

generate-commit-message() {
	model="$1"
	echo "Generating commit message using `model-name $model` ..."
	if [ -e "$commit_message" ]; then
		echo >&2 "Commit message already exists: $commit_message, moving it to rubbish."
		$MR "$commit_message"
	fi

	run-git-diff |
	llm process -m $model 'Please describe this entire patch, for a git commit message, following the Conventional Commits spec.
Do not invent anything that is not in the patch!
Only describe the actual changes, lines starting with +, do not describe the surrounding patch context.
The required format is as follows, return only the commit message like this without any prelude or concluding statement!

```
feat|fix|docs|style|refactor|test|chore|perf(short-module-name): a short summary line, preferably around 50 chars, not more than 70 chars

- concise info about first change, if needed. If the line wraps
  the second line must be indented like this.
- concise info about second change, if any.
- and so on ...
```

There can be only one feat or fix line per commit, then a blank line, then the list.
If a commit is simple, you can omit the list. Do not add a list item that just repeats the main line.
The (short-module-name) part is optional. Commit type can be feat|fix|chore etc.
Do not belabour the obvious; we do not need too much detail, e.g. moving folders do not list every file that was moved.
' | grep -v '^```' |
	fmt -s -w 78 -g 78 > "$commit_message"
}

check-for-bugs() {
	model="$1"
	echo "Checking for bugs using `model-name $model` ..."
	if [ -e "$review" ]; then
		echo >&2 "Code review already exists: $review, moving it to rubbish."
		$MR "$review"
	fi
	run-git-diff |
		proc -m=$model 'Please carefully review this patch with a fine-tooth comb! Answer LGTM if bug-free, or list bugs still present in the patched code. Do NOT list bugs in the original code that are fixed by the patch. You may also list other issues or suggestions if they are important. Expected format:
```
1. bug or issue
2. another bug or issue
```

or just LGTM.
' |
		fmt -s -w 78 -g 78 |
		tee "$review"
#		llm process -m $model 'Please do a code review: check this diff carefully for bugs, and tell me in brief about any bugs, other issues, or suggestions to improve it.' |
}

if [ -n "$model" ]; then
	confirm check-for-bugs "$model"
	if [ "`cat "$review"`" = "LGTM" ]; then
		generate-commit-message "$model"
	fi
fi

cleanup-and-exit() {
	$MR "$commit_message" "$review" 2>/dev/null
	exit "$1"
}

run-git-vimdiff() {
	if [ "${#files[@]}" -eq 0 ]; then
		git-vimdiff-staged
	else
		git-vimdiff "${files[@]}"
	fi
}

while true; do
	if [ -e "$commit_message" ]; then
		cat "$commit_message"
		echo
		prompt="Commit with this message?"
	else
		prompt="Action?"
	fi
	read -p "$prompt [y/n/q/e/3/4/c/C/i/I/d/v/b/?] " -n 1 -r choice 2>&1
	echo
	case "$choice" in
		y) break;;
		n|q)
			cleanup-and-exit 1
			;;
		e)
			${EDITOR:-vi} "$commit_message"
			;;
		3)
			generate-commit-message 3+
			;;
		4)
			generate-commit-message 4
			;;
		c)
			generate-commit-message c
			;;
		C)
			generate-commit-message c+
			;;
		i)
			generate-commit-message i
			;;
		I)
			generate-commit-message I
			;;
		d)
			run-git-diff
			;;
		v)
			run-git-vimdiff
			;;
		b)
			check-for-bugs c
			;;
		x)
			cleanup
			;;
		\?|h)
			echo "y: commit with this message"
			echo "n|q: abort"
			echo "e: edit the message"
			echo "3: generate with ChatGPT-3.5"
			echo "4: generate with GPT-4"
			echo "c: generate with Claude"
			echo "C: generate with Claude 100k"
			echo "i: generate with Cluade Instant"
			echo "d: diff the staged changes"
			echo "v: vimdiff the staged changes"
			echo "b: check for bugs with Claude"
			echo "?: show this help message"
			echo "x: clean up commit-message.*.txt files"
			echo
			;;
		*)
			echo "Invalid choice"
			;;
	esac
done

if [ "${#files[@]}" -gt 0 ]; then
	git add -- "${files[@]}"
fi

git commit -F "$commit_message"
