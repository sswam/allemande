# opts: a simple option parser for bash
# no dependencies, no magic, no bullshit


# Note: the basic function of setting a flag or string-valued option works well.
# There was an attempt to add the option to set arrays and associative arrays,
# and even functions, but I don't know if that works or not!  Probably not.


usage() {
	# read the script itself to output usage:

	case "$*" in
	-h|-help|--help)
		# if -h was passed, not an error: output usage to stdout
		exit=0
		;;
	*)
		# error: if a message was passed, output it to stderr
		exit=1
		exec >&2
		if [ -n "$*" ]; then
			echo "$*"
			echo
		fi
		;;
	esac

	# read the script itself and write help / usage to stdout
	local script_name=`basename "$0"`
	printf "%s: " "$script_name"
	local line
	while read -r line; do
		# Skip shebang line
		if [[ $line == \#\!* ]]; then
			continue
		fi

		# Remove '# ' from start of lines
		line="${line#\#}"
		line="${line# }"

		# Replace literal '$0' in lines with the value of $script_name
		line="${line//\$0 /$script_name }"

		# Stop at the ". opts" line
		if [ "$line" = ". opts" ]; then
			break
		fi
		echo "$line"
	done < "$0"

	exit $exit
}

OPTS_UNKNOWN=()
OPTS=()
OPTS_N=0

opts_set_scalar() {
	local type=$1 OPT=$2 VAL=$3

	# check that $OPT is declared as a string or an int
	if [ "$type" != "string" ] && [ "$type" != "int" ]; then
		usage "error: not a string or an int: $OPT"
	fi

	# check int
	if [ "$type" = "int" ] && ! [[ $VAL =~ ^[0-9]+$ ]]; then
		usage "error: not an int: $OPT=$VAL"
	fi

	eval $OPT=\$VAL
}

opts_set_array() {
	local type=$1 OPT=$2 VAL=$3

	# check that $OPT is declared as an array
	if [ "$type" != "array" ]; then
		usage "error: not an array: $OPT"
	fi

	# if OPTVAL is foo,a,b,c
	# then set OPT as an array to (a b c)

	local IFS_OLD=$IFS
	eval IFS=, $OPT=\(\$VAL\)
	IFS=$IFS_OLD
}

opts_set_assoc() {
	# TODO this doesn't work yet
	local type=$1 OPT=$2 VAL=$3

	# check that $OPT is declared as an assoc
	if [ "$type" != "assoc" ]; then
		usage "error: not an associative array: $OPT"
	fi

	local IFS_OLD=$IFS
	eval IFS=, $OPT=\(\$VAL\)
	IFS=$IFS_OLD
}

while true; do
	case "${1:-}" in
	"")
		break
		;;
	-|--)
		shift
		break
		;;
	-h|-help|--help)
		usage -h
		;;
	[!-]*)
		break
		;;
	esac

	OPTS[$OPTS_N]="$1"
	OPTVAL="${1#-}"
	OPTVAL="${OPTVAL#-}"

	OPT=${OPTVAL%%[=,\[]*}
	OPT="${OPT//-/_}"
	# if $OPT doesn't start with a letter, add opt_ prefix
	if ! [[ $OPT =~ ^[a-zA-Z] ]]; then
		OPT="opt_$OPT"
	fi

	OPTS_DECLARATION=`declare -p "$OPT" 2>/dev/null || true`

	case "$OPTS_DECLARATION" in
	declare\ -a*)
		type=array
		;;
	declare\ -A*)
		type=assoc
		;;
	declare\ -i*)
		type=int
		;;
	*)
		type=string
		;;
	esac

	# check if there's a function named $OPT, use declare -F
	function=0
	if declare -F "$OPT" >/dev/null 2>&1; then
		function=1
	fi

	if [ -z "$type" ]; then
		OPTS_UNKNOWN+=("$OPT")
	fi

	case "$OPTVAL" in
	*=*)
		VAL=${OPTVAL#*=}
		opts_set_scalar "$type" "$OPT" "$VAL"
		;;
	*,*)
		VAL=${OPTVAL#*,}
		opts_set_array "$type" "$OPT" "$VAL"
		;;
	*\[*\])
		VAL=${OPTVAL#*\[}
		VAL=${VAL%]}
		opts_set_assoc "$type" "$OPT" "$VAL"
		;;
	*:*)
		VAR=${OPTVAL%:*}
		opts_set_func "$function" "$OPT" "$VAR"
		;;
	*)
		opts_set_scalar "$type" "$OPT" 1
		eval $OPT=1
		;;
	esac
	shift
	OPTS_N=$[$OPTS_N + 1]
done

if [ ${#OPTS_UNKNOWN[@]} -gt 0 ]; then
	usage "error: unknown options: ${OPTS_UNKNOWN[*]}"
fi


# # usage from bash
# # e.g. for a -debug switch and -mode=foo option:
#
# #!/bin/bash
# debug=
# mode=normal
# . opts
# if (( debug )); then echo "debug mode"; fi
# echo "mode=$mode"
# echo opts: "${OPTS[@]}"
# echo args: "$@"

# There are four syntaxes for options:
# -foo		set $foo to 1
# -foo=bar	set $foo to bar
# -foo,a,b,c	set $foo to (a b c)
# -foo[a=b,c=d]	set $foo to (a=b c=d)
